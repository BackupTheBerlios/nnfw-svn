/*! \page overture Overture: the first application
\addindex overture
\htmlonly
<div id="navigationBar">
<a href="introduction.html"><img src="../img/prevChapter.png"></a> <a href="index.html"><img src="../img/mainToc.png"></a> <a href="mathstuff.html"><img src="../img/nextChapter.png"></a>
</div>
\endhtmlonly
\anchor overture_toc
<div id="tocContent_nohead">
<ul class="level_one">
    <li>\ref overture_1 </li>
    <li>\ref overture_2 </li>
    <li>\ref overture_3 </li>
</ul>
</div>

\section overture_1 The XOR problem

It's a classic in neural network field.

\section overture_2 The Implementation with NNFW

\section overture_21 Create the Net

\code
#include "nnfw.h"
#include "biasedcluster.h"
#include "dotlinker.h"
#include "liboutputfunctions.h"
#include "backpropagationalgo.h"
#include "random.h"
using namespace nnfw;

//-------- Neural Network Structures
BiasedCluster *in, *hid, *out;
DotLinker *l1, *l2;
BaseNeuralNet* net;

int main( int , char*  ) {
    Random::setSeed( time(0) );

    net = new BaseNeuralNet();

    // --- Create the Layers of network    
    in = new BiasedCluster( 2 );
    in->setFunction( SigmoidFunction( 1.0f ) );
    hid = new BiasedCluster( 4 );
    hid->setFunction( SigmoidFunction( 1.0f ) );
    out = new BiasedCluster( 1 );
    out->setFunction( SigmoidFunction( 1.0f ) );

    // --- Create the Matrix connection among layers
    l1 = new DotLinker( in, hid );
    l2 = new DotLinker( hid, out );

    // --- Add all in the BaseNeuralNet class
    net->addCluster( in, true );
    net->addCluster( hid );
    net->addCluster( out, false, true );
    net->addLinker( l1 );
    net->addLinker( l2 );
    // --- Specify the order on which layers and matrix weight will be updated
    UpdatableVec ord;
    net->setOrder( ord << in << l1 << hid << l2 << out );

    // --- Randomize the parameters of network (biases of neuron's layers and weight of matrix linkers)
    net->randomize( -1.0, 1.0 );
\endcode

\section overture_22 Create the BackPropagation Algorithm

\code
    UpdatableVec bp_ord;
	bp_ord << out << l2 << hid << l1 << in;
	BackPropagationAlgo* bp = new BackPropagationAlgo( net, bp_ord, 0.2 );
\endcode

\section overture_23 Define the problem... and learn it

\code
    // --- The learning Set - each row is a pattern
	RealMat xorT( 4, 3 );
	xorT[0][0] = 0.0; xorT[0][1] = 0.0; xorT[0][2] = 0.0;
	xorT[1][0] = 0.0; xorT[1][1] = 1.0; xorT[1][2] = 1.0;
	xorT[2][0] = 1.0; xorT[2][1] = 0.0; xorT[2][2] = 1.0;
	xorT[3][0] = 1.0; xorT[3][1] = 1.0; xorT[3][2] = 0.0;
    Real errorNet;
    RealVec tmp( 1 );
    int i;
    // --- Main loop for learning the network
    for( i = 0; i<50000; i++ ) {
        errorNet = 0.0;
        for( int j = 0; j<4; j++ ) {
            // --- set the input of current example
            in->setInput( 0, xorT[j][0] );
            in->setInput( 1, xorT[j][1] );
            // --- compute the output
            net->step();
            // --- set the Teachin input
			tmp[0] = xorT[j][2];
			bp->setTeachingInput( out, tmp );
			bp->learn();
        }
        // ---- Compare outputs with desired patterns
        for( int j = 0; j<4; j++ ) {
            in->setInput( 0, xorT[j][0] );
            in->setInput( 1, xorT[j][1] );
            net->step();
            errorNet += fabs( xorT[j][2] - out->getOutput( 0 ) );
        }
        if ( i%1000 == 0 ) {
            cout << "Error: " << errorNet << endl;
        }
        if ( errorNet < 0.01 ) {
            break;
        }
    }
    cout << "Iterations: " << i << endl;
    // Compare outputs with desired patterns
    for( int j = 0; j<4; j++ ) {
        in->setInput( 0, xorT[j][0] );
        in->setInput( 1, xorT[j][1] );
        net->step();
        cout << "Target: " << xorT[j][2] << "\tRete: " << (out->getOutput( 0 )>0.5 ? 1.0 : 0.0) << "\t" << out->getOutput(0) << endl;
    }

    return 0;
}
\endcode

\section overture_3 Defining the Neural Network using XML file

\section overture_31 Create the file

\section overture_32 The Code for using the file

\section overture_33 Run the application with different architecture


*/

